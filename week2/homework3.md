## 宿題3　質問
もっとも直近にアクセスされたページ上位 X 個をキャッシュしておくというようなキャッシュの管理をほぼ O(1) で実現できるデータ構造を考えて

##  解答
#### 1 以下のデータ構造だと検索にO(X)かかってしまう、追加、削除にもO(X)かかる
- X個の配列を用意して時系列新しい順に並べると決める(0が新しい、X-1が古い)
- 配列の中の要素は<url,webpage>のペアを格納する
- 0から順に探索をしてヒットしたらそれを返す
- ヒットしなければX-1のデータを削除して一つ後ろにずらす、0に新しいデータを格納する

#### 2 以下のデータ構造だと検索、削除にO(X),追加にO(1)
- 考え方は先ほどのまま、Linked Listにする
- つまり、それぞれの要素に<url,webpage,nextアドレス>を格納する
- 追加は先頭要素に追加しれば良いのでO(1)
- 削除は一番最後から二番目のnextアドレスをnullにする必要がある

#### 3 ハッシュとlinked listを組み合わせるとO(1)?
- webpageを元にハッシュ値を計算してハッシュテーブルに格納
- 要素は<url,webpage,nextアドレス>
- 検索はハッシュを用いれば良いのでO(1)(衝突を無視した場合)
- 追加は先頭要素に追加すれば良いのでO(1)
- 削除はnextアドレスを辿って最終要素を削除するのでO(X)
- つまり新しいページを追加する時には最終要素を削除してから追加するのでO(X)になっちゃう
- しかもハッシュ値を計算して例えばmodXにしたとしても衝突する可能性がある
- Directory access Tableにするにはどうしたら良いのかわからない

#### 4 キューを用いることができれば追加、削除はO(1)??
- どのように実装したら良いのかという部分の想像がついていないが、キューの考え方を用いることができれば追加および削除はO(1)で実装することができそう
- ただし検索にはO(X)かかってしまうのに変わりはないのでは？と思っているのでこの部分にハッシュの考え方を適用する必要があることには変わりがないように思う

#### 5 ハッシュテーブルと双方向のLinked listにすればいい　(メンターさんに教えていただきました。)
- webpageを元にハッシュ値を計算してハッシュテーブルに格納
- 要素は<url,webpage,nextアドレス,prevアドレス>
- こうすることで先頭要素だけでなく、最後の要素を格納することができる
- 検索はハッシュを用いてO(1)
- 追加は先頭に追加すれば良いのでO(1)
- 削除は最後の要素を格納していて、それを削除すればいいのでO(1)
- つまり全ての工程をO(1)で実装することが可能